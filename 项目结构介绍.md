rabbitmqInit：rabbitmq原生 api使用；具体参考org.apache.base.exchange包下四种交换器的不同例子。


知识点：
一、rabbitmq 四种交换器：
    1、DIRECT：表示交换器和队列通过路由键全名匹配 ；参考org.apache.base.exchange.direct
    2、FANOUT：表示忽略路由键，广播到所有的队列上 ；参考org.apache.base.exchange.fanout
    3、TOPIC：通过通配符*、#匹配后把消息传递到队列上 ；参考org.apache.base.exchange.topic
    
    
二、生产者的性能和可靠性权衡：
    失败通知、发布者确认、备用交换器、高可用队列、事务、事务+高可用队列、消息持久化
    从左到右可靠性越来越高、性能越来越差。
    常用策略：失败通知、发布者确认、备用交换器、高可用队列、消息持久化 
    基本不怎么用：事务、事务+高可用队列（性能会下降2~10倍）
    要根据业务的特性；如果需求提高要保证可靠性；则就要加入事务，但是加入事务不代表每个信道都是开启的事务。每个信道使用不同的策略是互不影响的。
    1、失败通知：当消息没有从交换器路由到队列时触发
       ①开发步骤：
            （1）生产者添加失败通知监听器：
             channel.addReturnListener(new ReturnListener() {
                            @Override
                            public void handleReturn(int replyCode, String replyText, String exchange, String routingKey, AMQP.BasicProperties properties, byte[] body) throws IOException {
                                String msg = new String(body);
                                System.out.println("返回的replyText ："+replyText);
                                System.out.println("返回的exchange ："+exchange);
                                System.out.println("返回的routingKey ："+routingKey);
                                System.out.println("返回的message ："+msg);
                            }
                        });
            （2）生产者在发送消息时设置mandatory=true：
                channel.basicPublish(EXCHANGE_NAME,routekey,true,null,msg.getBytes());//第三个参数：mandatory=true
       ②具体参考：org.apache.base.mandatory.MandatoryProducer
    2、发布者确认：生产者自身确认；确认方式有：同步单条确认、同步批量确认、异步确认
       ①开发步骤：
        （1）单条确认：
            生产者在发送前开启发送者确认模式：channel.confirmSelect();
            生产者在调用了一次channel.basicPublish后调用channel.waitForConfirms()；返回值为true时表示正常路由到了队列
        （2）批量确认：
            生产者在发送前开启发送者确认模式：channel.confirmSelect();
            生产者在调用了多次channel.basicPublish后调用channel.waitForConfirmsOrDie()；进行批量确认，此方法无返回值
        （3）异步确认：
            生产者在发送前开启发送者确认模式：channel.confirmSelect();
            生产者添加确认监听器：
            channel.addConfirmListener(new ConfirmListener() {
                        public void handleAck(long deliveryTag, boolean multiple)
                                throws IOException {
                            System.out.println("deliveryTag:"+deliveryTag +",multiple:"+multiple);
                        }
                        public void handleNack(long deliveryTag, boolean multiple)
                                throws IOException {
                        }
                    });
      ②具体参考：
        单条确认：org.apache.base.producerconfirm.ProducerConfirm
        批量确认：org.apache.base.producerconfirm.ProducerBatchConfirm
        异步确认：org.apache.base.producerconfirm.ProducerConfirmAsync
    3、备用交换器：当消息没有被路由时，最终路由到备用交换器上；如果启动了失败通知，生产者不会接受到失败通知，因为消息最终都会被路由走
        ①开发步骤：
            （1）在生产者添加备用交换器
                    // 声明备用交换器
                    Map<String,Object> argsMap = new HashMap<String,Object>();
                    argsMap.put("alternate-exchange",BAK_EXCHANGE_NAME);
                    //备用交换器
                    channel.exchangeDeclare(BAK_EXCHANGE_NAME,BuiltinExchangeType.FANOUT,true,false,null);//备用交换器类型推荐使用FANOUT类型
                    //主交换器
                    channel.exchangeDeclare(EXCHANGE_NAME,"direct", false,false,argsMap);
            （2）创建备用交换器的消费者：备用交换器是一个还是多个根据业务进行设计
                    channel.queueBind(queueName,BackupExProducer.BAK_EXCHANGE_NAME, "#");//这里表示队列接受所有未被路由消息
        ②具体参考：
         生产者：org.apache.base.backupexchange.BackupExProducer
         备用交换器消费者：org.apache.base.backupexchange.BackupExConsumer          
    4、高可用队列（集群后续补充，rabbitmq没有主从，只有负载）
    5、事务：由于开启事务导致性能下降很多，在生产上很少使用（根据业务必要时使用）
        ①开发步骤：
            （1）在发送消息前启用事务：
                channel.txSelect();
                发送消息成功后：
                channel.txCommit();
                发送消息返回失败后：
                channel.txRollback();
        ②具体参考
            生产者：org.apache.base.transaction.ProducerTransaction
    6、消息持久化：保存到磁盘；交换器默认是持久化消息的
ps：如何选择哪几种策略，根据业务需求来判断：如果消息不重要则什么都不配置都可以，如果消息挺重要的就可以选择失败通知、发布者确认、备用交换器进行配置；
如果消息特别重要，可选择配置事务。这些策略都是几个一起混搭的。   

三、消费者的性能和可靠性权衡：
    1、拉取方式：
        ①get阻塞方式：
            （1）开发步骤：
            消费者调用并返回GetResponse getResponse =channel.basicGet(queueName, true);//轮询获取并阻塞，每调用一次只接受一条消息。
            （2）具体参考：org.apache.base.getmessage.GetMessageConsumer
        ②consumer异步方式：
            （1）开发步骤：
            消费者调用channel.basicConsume(queueName,true,consumer);//异步调用；消息没有生产者确认不会接受到下一条消息。
            （2）具体参考：org.apache.base.exchange.direct.DirectProducer
    2、消息的应答方式：
        ①自动确认：
            （1）开发步骤：
                channel.basicGet(queueName, true);或者channel.basicConsume(queueName,true,consumer);//true表示自动应答
            （2）具体参考：org.apache.base.exchange.direct.NormalConsumer
        ②手动确认：
            （1）开发步骤：
                消费者定义消费者并且调用channel.basicConsume时传入false；
                    /*声明了一个消费者*/
                    final Consumer consumer = new DefaultConsumer(channel){
                        @Override
                        public void handleDelivery(String consumerTag,Envelope envelope,AMQP.BasicProperties properties,byte[] body) throws IOException {
                            try {
                                String message = new String(body, "UTF-8");
                                System.out.println("Received["+envelope.getRoutingKey()+"]"+message);
                                //如果没有调用应答方法，消费者和rabbitmq也没有断开连接，则消息就不会转发给其他消费者，消费者和rabbitmq断开连接则吧消息转发给下一个消费者
                                channel.basicAck(envelope.getDeliveryTag(),false);//手动应答；false表示单条消息应答，true表示批量应答。
                            } catch (UnsupportedEncodingException e) {
                                e.printStackTrace();
                                //拒绝
                            }
                        }
                    };
                    /*消费者正式开始在指定队列上消费消息*/
                    channel.basicConsume(queueName,false,consumer);//false表示手动应答
            （2）具体参考：org.apache.base.ackfalse.AckFalseConsumerB
    3、消息批量预取（qos）:rabbitmq性能最快12000/s的时候就是qos设置为2500
        ①开发步骤：
         设置方式1：
            channel.basicQos(150,true);//表示整个信道最多同时消费150个消息
         设置方式2：
            channel.basicQos(100,false); //表示一个信道可以有多个消费者，每个消费者批量最多同时消费100个消息
         ps：方式1和方式2选择一种
         ②具体参考：org.apache.base.qos.QosConsumerMain
    4、消息确认：
        ①单个确认
          （1）开发步骤：
                new DefaultConsumer(channel){
                            @Override
                            public void handleDelivery(String consumerTag,Envelope envelope,AMQP.BasicProperties properties,
                                                       byte[] body) throws IOException {
                                String message = new String(body, "UTF-8");
                                System.out.println("Received["+envelope.getRoutingKey()+"]"+message);
                                channel.basicAck(envelope.getDeliveryTag(),false);//false表示三个确认
                            }
                        };
          （2）具体参考：org.apache.base.qos.QosConsumerMain
        ②批量确认：批量确认的数量必须小于等于qos数量；批量确认容易产生消息重复消费；当消费者处理了一半以后异常，然后这批消息就会转发到下一个消费者，因此有一半的消息被重复处理。
          （1）开发步骤
             new DefaultConsumer(channel){
                        @Override
                        public void handleDelivery(String consumerTag, Envelope envelope,
                                                   AMQP.BasicProperties properties,
                                                   byte[] body) throws IOException {
                            String message = new String(body, "UTF-8");
                            System.out.println("批量消费者Received["+envelope.getRoutingKey()
                                    +"]"+message);
                            messasgeCount++;
                            if (messasgeCount % 50==0){
                                this.getChannel().basicAck(envelope.getDeliveryTag(),
                                        true);
                                System.out.println("批量消费者进行消息的确认-------------");
                            }
                            if(message.equals("stop")){
                                this.getChannel().basicAck(envelope.getDeliveryTag(), true);//true表示批量确认
                                System.out.println("批量消费者进行最后部分业务消息的确认-------------");
                            }
                        }
                    };
         （2）具体参考： org.apache.base.qos.BatchAckConsumer
ps：使用事务+拉取的方式可靠性最高；使用qos的方式性能最高。为了提高性能最常使用的就是消费者qos批量拉取和批量确认。